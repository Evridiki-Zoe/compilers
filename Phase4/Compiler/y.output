Grammar

    0 $accept: program $end

    1 program: multi_stmts

    2 $@1: %empty

    3 $@2: %empty

    4 multi_stmts: $@1 stmt $@2 multi_stmts
    5            | %empty

    6 stmt: expr SEMICOLON
    7     | ifstmt
    8     | whilestmt
    9     | forstmt
   10     | returnstmt
   11     | BREAK SEMICOLON
   12     | CONTINUE SEMICOLON
   13     | block
   14     | funcdef
   15     | SEMICOLON

   16 expr: assignmexpr
   17     | boolResexpr
   18     | arexpr

   19 $@3: %empty

   20 expr: expr AND $@3 epsilon expr

   21 $@4: %empty

   22 expr: expr OR $@4 epsilon expr
   23     | NOT expr
   24     | term

   25 epsilon: %empty

   26 arexpr: expr PLUS expr
   27       | expr MINUS expr
   28       | expr MULT expr
   29       | expr DIV expr
   30       | expr MOD expr

   31 boolResexpr: expr GREATER expr
   32            | expr GREATER_EQUAL expr
   33            | expr LESS expr
   34            | expr LESS_EQUAL expr
   35            | expr EQUAL expr
   36            | expr NEQUAL expr

   37 $@5: %empty

   38 term: L_PARENTHES $@5 expr R_PARENTHES
   39     | MINUS expr
   40     | PPLUS lvalue
   41     | lvalue PPLUS
   42     | MMINUS lvalue
   43     | lvalue MMINUS
   44     | primary

   45 $@6: %empty

   46 assignmexpr: lvalue $@6 EQ expr

   47 primary: lvalue
   48        | call
   49        | objectdef
   50        | L_PARENTHES funcdef R_PARENTHES
   51        | const

   52 lvalue: IDENTIFIER
   53       | LOCAL IDENTIFIER
   54       | DCOLON IDENTIFIER
   55       | member

   56 member: lvalue DOT IDENTIFIER
   57       | lvalue L_SBRACKET expr R_SBRACKET
   58       | call DOT IDENTIFIER
   59       | call L_SBRACKET expr R_SBRACKET

   60 call: call L_PARENTHES elist R_PARENTHES
   61     | lvalue callsuffix
   62     | L_PARENTHES funcdef R_PARENTHES L_PARENTHES elist R_PARENTHES

   63 callsuffix: normcall
   64           | methodcall

   65 normcall: L_PARENTHES elist R_PARENTHES

   66 methodcall: DOTS IDENTIFIER L_PARENTHES elist R_PARENTHES

   67 elist: expr multi_exprs
   68      | %empty

   69 multi_exprs: COMMA expr multi_exprs
   70            | %empty

   71 objectdef: L_SBRACKET elist_for_table R_SBRACKET
   72          | L_SBRACKET indexed R_SBRACKET

   73 elist_for_table: expr multi_exprs_for_table
   74                | %empty

   75 multi_exprs_for_table: COMMA expr multi_exprs_for_table
   76                      | %empty

   77 indexed: indexedelem multi_indexedelem

   78 multi_indexedelem: COMMA indexedelem multi_indexedelem
   79                  | %empty

   80 $@7: %empty

   81 indexedelem: L_CBRACKET expr $@7 COLON expr R_CBRACKET

   82 $@8: %empty

   83 block: L_CBRACKET $@8 multi_stmts R_CBRACKET

   84 $@9: %empty

   85 $@10: %empty

   86 funcdef: funcstart funcname L_PARENTHES $@9 idlist R_PARENTHES $@10 block

   87 funcstart: FUNCTION

   88 funcname: IDENTIFIER
   89         | %empty

   90 const: number
   91      | STRING
   92      | NIL
   93      | TRUE
   94      | FALSE

   95 number: INTEGER
   96       | FLOAT

   97 $@11: %empty

   98 idlist: IDENTIFIER $@11 multi_id
   99       | %empty

  100 $@12: %empty

  101 multi_id: COMMA IDENTIFIER $@12 multi_id
  102         | %empty

  103 $@13: %empty

  104 ifstmt: if_start R_PARENTHES stmt ELSE $@13 stmt
  105       | if_start R_PARENTHES stmt

  106 if_start: IF L_PARENTHES expr

  107 whilestmt: whilestart whilecond stmt

  108 whilestart: WHILE

  109 $@14: %empty

  110 $@15: %empty

  111 whilecond: L_PARENTHES $@14 expr $@15 R_PARENTHES

  112 $@16: %empty

  113 $@17: %empty

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

  115 for_elist: expr multi_exprs
  116          | %empty

  117 for_cond: expr

  118 for_end: for_elist

  119 returnstmt: RETURN expr SEMICOLON
  120           | RETURN SEMICOLON


Terminals, with rules where they appear

$end (0) 0
error (256)
IF (258) 106
ELSE (259) 104
WHILE (260) 108
FOR (261) 114
FUNCTION (262) 87
RETURN (263) 119 120
BREAK (264) 11
CONTINUE (265) 12
AND (266) 20
NOT (267) 23
OR (268) 22
LOCAL (269) 53
TRUE (270) 93
FALSE (271) 94
NIL (272) 92
EQ (273) 46
PLUS (274) 26
MINUS (275) 27 39
MULT (276) 28
DIV (277) 29
MOD (278) 30
EQUAL (279) 35
NEQUAL (280) 36
PPLUS (281) 40 41
MMINUS (282) 42 43
GREATER (283) 31
LESS (284) 33
GREATER_EQUAL (285) 32
LESS_EQUAL (286) 34
SEMICOLON (287) 6 11 12 15 114 119 120
COMMA (288) 69 75 78 101
COLON (289) 81
DCOLON (290) 54
DOT (291) 56 58
DOTS (292) 66
L_CBRACKET (293) 81 83
R_CBRACKET (294) 81 83
L_SBRACKET (295) 57 59 71 72
R_SBRACKET (296) 57 59 71 72
L_PARENTHES (297) 38 50 60 62 65 66 86 106 111 114
R_PARENTHES (298) 38 50 60 62 65 66 86 104 105 111 114
INTEGER (299) 95
FLOAT (300) 96
STRING (301) 91
IDENTIFIER (302) 52 53 54 56 58 66 88 98 101
UMINUS (303)


Nonterminals, with rules where they appear

$accept (49)
    on left: 0
program (50)
    on left: 1, on right: 0
multi_stmts (51)
    on left: 4 5, on right: 1 4 83
$@1 (52)
    on left: 2, on right: 4
$@2 (53)
    on left: 3, on right: 4
stmt (54)
    on left: 6 7 8 9 10 11 12 13 14 15, on right: 4 104 105 107 114
expr (55)
    on left: 16 17 18 20 22 23 24, on right: 6 20 22 23 26 27 28 29
    30 31 32 33 34 35 36 38 39 46 57 59 67 69 73 75 81 106 111 115
    117 119
$@3 (56)
    on left: 19, on right: 20
$@4 (57)
    on left: 21, on right: 22
epsilon (58)
    on left: 25, on right: 20 22
arexpr (59)
    on left: 26 27 28 29 30, on right: 18
boolResexpr (60)
    on left: 31 32 33 34 35 36, on right: 17
term (61)
    on left: 38 39 40 41 42 43 44, on right: 24
$@5 (62)
    on left: 37, on right: 38
assignmexpr (63)
    on left: 46, on right: 16
$@6 (64)
    on left: 45, on right: 46
primary (65)
    on left: 47 48 49 50 51, on right: 44
lvalue (66)
    on left: 52 53 54 55, on right: 40 41 42 43 46 47 56 57 61
member (67)
    on left: 56 57 58 59, on right: 55
call (68)
    on left: 60 61 62, on right: 48 58 59 60
callsuffix (69)
    on left: 63 64, on right: 61
normcall (70)
    on left: 65, on right: 63
methodcall (71)
    on left: 66, on right: 64
elist (72)
    on left: 67 68, on right: 60 62 65 66
multi_exprs (73)
    on left: 69 70, on right: 67 69 115
objectdef (74)
    on left: 71 72, on right: 49
elist_for_table (75)
    on left: 73 74, on right: 71
multi_exprs_for_table (76)
    on left: 75 76, on right: 73 75
indexed (77)
    on left: 77, on right: 72
multi_indexedelem (78)
    on left: 78 79, on right: 77 78
indexedelem (79)
    on left: 81, on right: 77 78
$@7 (80)
    on left: 80, on right: 81
block (81)
    on left: 83, on right: 13 86
$@8 (82)
    on left: 82, on right: 83
funcdef (83)
    on left: 86, on right: 14 50 62
$@9 (84)
    on left: 84, on right: 86
$@10 (85)
    on left: 85, on right: 86
funcstart (86)
    on left: 87, on right: 86
funcname (87)
    on left: 88 89, on right: 86
const (88)
    on left: 90 91 92 93 94, on right: 51
number (89)
    on left: 95 96, on right: 90
idlist (90)
    on left: 98 99, on right: 86
$@11 (91)
    on left: 97, on right: 98
multi_id (92)
    on left: 101 102, on right: 98 101
$@12 (93)
    on left: 100, on right: 101
ifstmt (94)
    on left: 104 105, on right: 7
$@13 (95)
    on left: 103, on right: 104
if_start (96)
    on left: 106, on right: 104 105
whilestmt (97)
    on left: 107, on right: 8
whilestart (98)
    on left: 108, on right: 107
whilecond (99)
    on left: 111, on right: 107
$@14 (100)
    on left: 109, on right: 111
$@15 (101)
    on left: 110, on right: 111
forstmt (102)
    on left: 114, on right: 9
$@16 (103)
    on left: 112, on right: 114
$@17 (104)
    on left: 113, on right: 114
for_elist (105)
    on left: 115 116, on right: 114 118
for_cond (106)
    on left: 117, on right: 114
for_end (107)
    on left: 118, on right: 114
returnstmt (108)
    on left: 119 120, on right: 10


State 0

    0 $accept: . program $end

    $end      reduce using rule 5 (multi_stmts)
    $default  reduce using rule 2 ($@1)

    program      go to state 1
    multi_stmts  go to state 2
    $@1          go to state 3


State 1

    0 $accept: program . $end

    $end  shift, and go to state 4


State 2

    1 program: multi_stmts .

    $default  reduce using rule 1 (program)


State 3

    4 multi_stmts: $@1 . stmt $@2 multi_stmts

    IF           shift, and go to state 5
    WHILE        shift, and go to state 6
    FOR          shift, and go to state 7
    FUNCTION     shift, and go to state 8
    RETURN       shift, and go to state 9
    BREAK        shift, and go to state 10
    CONTINUE     shift, and go to state 11
    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 20
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 22
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    stmt         go to state 29
    expr         go to state 30
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    block        go to state 40
    funcdef      go to state 41
    funcstart    go to state 42
    const        go to state 43
    number       go to state 44
    ifstmt       go to state 45
    if_start     go to state 46
    whilestmt    go to state 47
    whilestart   go to state 48
    forstmt      go to state 49
    returnstmt   go to state 50


State 4

    0 $accept: program $end .

    $default  accept


State 5

  106 if_start: IF . L_PARENTHES expr

    L_PARENTHES  shift, and go to state 51


State 6

  108 whilestart: WHILE .

    $default  reduce using rule 108 (whilestart)


State 7

  114 forstmt: FOR . L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

    L_PARENTHES  shift, and go to state 52


State 8

   87 funcstart: FUNCTION .

    $default  reduce using rule 87 (funcstart)


State 9

  119 returnstmt: RETURN . expr SEMICOLON
  120           | RETURN . SEMICOLON

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 53
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 54
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 10

   11 stmt: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 55


State 11

   12 stmt: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 56


State 12

   23 expr: NOT . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 57
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 13

   53 lvalue: LOCAL . IDENTIFIER

    IDENTIFIER  shift, and go to state 58


State 14

   93 const: TRUE .

    $default  reduce using rule 93 (const)


State 15

   94 const: FALSE .

    $default  reduce using rule 94 (const)


State 16

   92 const: NIL .

    $default  reduce using rule 92 (const)


State 17

   39 term: MINUS . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 59
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 18

   40 term: PPLUS . lvalue

    LOCAL        shift, and go to state 13
    DCOLON       shift, and go to state 21
    L_PARENTHES  shift, and go to state 60
    IDENTIFIER   shift, and go to state 28

    lvalue  go to state 61
    member  go to state 37
    call    go to state 62


State 19

   42 term: MMINUS . lvalue

    LOCAL        shift, and go to state 13
    DCOLON       shift, and go to state 21
    L_PARENTHES  shift, and go to state 60
    IDENTIFIER   shift, and go to state 28

    lvalue  go to state 63
    member  go to state 37
    call    go to state 62


State 20

   15 stmt: SEMICOLON .

    $default  reduce using rule 15 (stmt)


State 21

   54 lvalue: DCOLON . IDENTIFIER

    IDENTIFIER  shift, and go to state 64


State 22

   83 block: L_CBRACKET . $@8 multi_stmts R_CBRACKET

    $default  reduce using rule 82 ($@8)

    $@8  go to state 65


State 23

   71 objectdef: L_SBRACKET . elist_for_table R_SBRACKET
   72          | L_SBRACKET . indexed R_SBRACKET

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 66
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 74 (elist_for_table)

    expr             go to state 67
    arexpr           go to state 31
    boolResexpr      go to state 32
    term             go to state 33
    assignmexpr      go to state 34
    primary          go to state 35
    lvalue           go to state 36
    member           go to state 37
    call             go to state 38
    objectdef        go to state 39
    elist_for_table  go to state 68
    indexed          go to state 69
    indexedelem      go to state 70
    const            go to state 43
    number           go to state 44


State 24

   38 term: L_PARENTHES . $@5 expr R_PARENTHES
   50 primary: L_PARENTHES . funcdef R_PARENTHES
   62 call: L_PARENTHES . funcdef R_PARENTHES L_PARENTHES elist R_PARENTHES

    FUNCTION  shift, and go to state 8

    $default  reduce using rule 37 ($@5)

    $@5        go to state 71
    funcdef    go to state 72
    funcstart  go to state 42


State 25

   95 number: INTEGER .

    $default  reduce using rule 95 (number)


State 26

   96 number: FLOAT .

    $default  reduce using rule 96 (number)


State 27

   91 const: STRING .

    $default  reduce using rule 91 (const)


State 28

   52 lvalue: IDENTIFIER .

    $default  reduce using rule 52 (lvalue)


State 29

    4 multi_stmts: $@1 stmt . $@2 multi_stmts

    $default  reduce using rule 3 ($@2)

    $@2  go to state 73


State 30

    6 stmt: expr . SEMICOLON
   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    SEMICOLON      shift, and go to state 87


State 31

   18 expr: arexpr .

    $default  reduce using rule 18 (expr)


State 32

   17 expr: boolResexpr .

    $default  reduce using rule 17 (expr)


State 33

   24 expr: term .

    $default  reduce using rule 24 (expr)


State 34

   16 expr: assignmexpr .

    $default  reduce using rule 16 (expr)


State 35

   44 term: primary .

    $default  reduce using rule 44 (term)


State 36

   41 term: lvalue . PPLUS
   43     | lvalue . MMINUS
   46 assignmexpr: lvalue . $@6 EQ expr
   47 primary: lvalue .
   56 member: lvalue . DOT IDENTIFIER
   57       | lvalue . L_SBRACKET expr R_SBRACKET
   61 call: lvalue . callsuffix

    PPLUS        shift, and go to state 88
    MMINUS       shift, and go to state 89
    DOT          shift, and go to state 90
    DOTS         shift, and go to state 91
    L_SBRACKET   shift, and go to state 92
    L_PARENTHES  shift, and go to state 93

    EQ        reduce using rule 45 ($@6)
    $default  reduce using rule 47 (primary)

    $@6         go to state 94
    callsuffix  go to state 95
    normcall    go to state 96
    methodcall  go to state 97


State 37

   55 lvalue: member .

    $default  reduce using rule 55 (lvalue)


State 38

   48 primary: call .
   58 member: call . DOT IDENTIFIER
   59       | call . L_SBRACKET expr R_SBRACKET
   60 call: call . L_PARENTHES elist R_PARENTHES

    DOT          shift, and go to state 98
    L_SBRACKET   shift, and go to state 99
    L_PARENTHES  shift, and go to state 100

    $default  reduce using rule 48 (primary)


State 39

   49 primary: objectdef .

    $default  reduce using rule 49 (primary)


State 40

   13 stmt: block .

    $default  reduce using rule 13 (stmt)


State 41

   14 stmt: funcdef .

    $default  reduce using rule 14 (stmt)


State 42

   86 funcdef: funcstart . funcname L_PARENTHES $@9 idlist R_PARENTHES $@10 block

    IDENTIFIER  shift, and go to state 101

    $default  reduce using rule 89 (funcname)

    funcname  go to state 102


State 43

   51 primary: const .

    $default  reduce using rule 51 (primary)


State 44

   90 const: number .

    $default  reduce using rule 90 (const)


State 45

    7 stmt: ifstmt .

    $default  reduce using rule 7 (stmt)


State 46

  104 ifstmt: if_start . R_PARENTHES stmt ELSE $@13 stmt
  105       | if_start . R_PARENTHES stmt

    R_PARENTHES  shift, and go to state 103


State 47

    8 stmt: whilestmt .

    $default  reduce using rule 8 (stmt)


State 48

  107 whilestmt: whilestart . whilecond stmt

    L_PARENTHES  shift, and go to state 104

    whilecond  go to state 105


State 49

    9 stmt: forstmt .

    $default  reduce using rule 9 (stmt)


State 50

   10 stmt: returnstmt .

    $default  reduce using rule 10 (stmt)


State 51

  106 if_start: IF L_PARENTHES . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 106
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 52

  114 forstmt: FOR L_PARENTHES . $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

    $default  reduce using rule 112 ($@16)

    $@16  go to state 107


State 53

  120 returnstmt: RETURN SEMICOLON .

    $default  reduce using rule 120 (returnstmt)


State 54

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
  119 returnstmt: RETURN expr . SEMICOLON

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    SEMICOLON      shift, and go to state 108


State 55

   11 stmt: BREAK SEMICOLON .

    $default  reduce using rule 11 (stmt)


State 56

   12 stmt: CONTINUE SEMICOLON .

    $default  reduce using rule 12 (stmt)


State 57

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   23     | NOT expr .
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    $default  reduce using rule 23 (expr)


State 58

   53 lvalue: LOCAL IDENTIFIER .

    $default  reduce using rule 53 (lvalue)


State 59

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   39 term: MINUS expr .

    $default  reduce using rule 39 (term)


State 60

   62 call: L_PARENTHES . funcdef R_PARENTHES L_PARENTHES elist R_PARENTHES

    FUNCTION  shift, and go to state 8

    funcdef    go to state 109
    funcstart  go to state 42


State 61

   40 term: PPLUS lvalue .
   56 member: lvalue . DOT IDENTIFIER
   57       | lvalue . L_SBRACKET expr R_SBRACKET
   61 call: lvalue . callsuffix

    DOT          shift, and go to state 90
    DOTS         shift, and go to state 91
    L_SBRACKET   shift, and go to state 92
    L_PARENTHES  shift, and go to state 93

    $default  reduce using rule 40 (term)

    callsuffix  go to state 95
    normcall    go to state 96
    methodcall  go to state 97


State 62

   58 member: call . DOT IDENTIFIER
   59       | call . L_SBRACKET expr R_SBRACKET
   60 call: call . L_PARENTHES elist R_PARENTHES

    DOT          shift, and go to state 98
    L_SBRACKET   shift, and go to state 99
    L_PARENTHES  shift, and go to state 100


State 63

   42 term: MMINUS lvalue .
   56 member: lvalue . DOT IDENTIFIER
   57       | lvalue . L_SBRACKET expr R_SBRACKET
   61 call: lvalue . callsuffix

    DOT          shift, and go to state 90
    DOTS         shift, and go to state 91
    L_SBRACKET   shift, and go to state 92
    L_PARENTHES  shift, and go to state 93

    $default  reduce using rule 42 (term)

    callsuffix  go to state 95
    normcall    go to state 96
    methodcall  go to state 97


State 64

   54 lvalue: DCOLON IDENTIFIER .

    $default  reduce using rule 54 (lvalue)


State 65

   83 block: L_CBRACKET $@8 . multi_stmts R_CBRACKET

    R_CBRACKET  reduce using rule 5 (multi_stmts)
    $default    reduce using rule 2 ($@1)

    multi_stmts  go to state 110
    $@1          go to state 3


State 66

   81 indexedelem: L_CBRACKET . expr $@7 COLON expr R_CBRACKET

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 111
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 67

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   73 elist_for_table: expr . multi_exprs_for_table

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    COMMA          shift, and go to state 112

    $default  reduce using rule 76 (multi_exprs_for_table)

    multi_exprs_for_table  go to state 113


State 68

   71 objectdef: L_SBRACKET elist_for_table . R_SBRACKET

    R_SBRACKET  shift, and go to state 114


State 69

   72 objectdef: L_SBRACKET indexed . R_SBRACKET

    R_SBRACKET  shift, and go to state 115


State 70

   77 indexed: indexedelem . multi_indexedelem

    COMMA  shift, and go to state 116

    $default  reduce using rule 79 (multi_indexedelem)

    multi_indexedelem  go to state 117


State 71

   38 term: L_PARENTHES $@5 . expr R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 118
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 72

   50 primary: L_PARENTHES funcdef . R_PARENTHES
   62 call: L_PARENTHES funcdef . R_PARENTHES L_PARENTHES elist R_PARENTHES

    R_PARENTHES  shift, and go to state 119


State 73

    4 multi_stmts: $@1 stmt $@2 . multi_stmts

    $end        reduce using rule 5 (multi_stmts)
    R_CBRACKET  reduce using rule 5 (multi_stmts)
    $default    reduce using rule 2 ($@1)

    multi_stmts  go to state 120
    $@1          go to state 3


State 74

   20 expr: expr AND . $@3 epsilon expr

    $default  reduce using rule 19 ($@3)

    $@3  go to state 121


State 75

   22 expr: expr OR . $@4 epsilon expr

    $default  reduce using rule 21 ($@4)

    $@4  go to state 122


State 76

   26 arexpr: expr PLUS . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 123
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 77

   27 arexpr: expr MINUS . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 124
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 78

   28 arexpr: expr MULT . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 125
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 79

   29 arexpr: expr DIV . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 126
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 80

   30 arexpr: expr MOD . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 127
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 81

   35 boolResexpr: expr EQUAL . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 128
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 82

   36 boolResexpr: expr NEQUAL . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 129
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 83

   31 boolResexpr: expr GREATER . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 130
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 84

   33 boolResexpr: expr LESS . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 131
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 85

   32 boolResexpr: expr GREATER_EQUAL . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 132
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 86

   34 boolResexpr: expr LESS_EQUAL . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 133
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 87

    6 stmt: expr SEMICOLON .

    $default  reduce using rule 6 (stmt)


State 88

   41 term: lvalue PPLUS .

    $default  reduce using rule 41 (term)


State 89

   43 term: lvalue MMINUS .

    $default  reduce using rule 43 (term)


State 90

   56 member: lvalue DOT . IDENTIFIER

    IDENTIFIER  shift, and go to state 134


State 91

   66 methodcall: DOTS . IDENTIFIER L_PARENTHES elist R_PARENTHES

    IDENTIFIER  shift, and go to state 135


State 92

   57 member: lvalue L_SBRACKET . expr R_SBRACKET

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 136
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 93

   65 normcall: L_PARENTHES . elist R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 68 (elist)

    expr         go to state 137
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    elist        go to state 138
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 94

   46 assignmexpr: lvalue $@6 . EQ expr

    EQ  shift, and go to state 139


State 95

   61 call: lvalue callsuffix .

    $default  reduce using rule 61 (call)


State 96

   63 callsuffix: normcall .

    $default  reduce using rule 63 (callsuffix)


State 97

   64 callsuffix: methodcall .

    $default  reduce using rule 64 (callsuffix)


State 98

   58 member: call DOT . IDENTIFIER

    IDENTIFIER  shift, and go to state 140


State 99

   59 member: call L_SBRACKET . expr R_SBRACKET

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 141
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 100

   60 call: call L_PARENTHES . elist R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 68 (elist)

    expr         go to state 137
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    elist        go to state 142
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 101

   88 funcname: IDENTIFIER .

    $default  reduce using rule 88 (funcname)


State 102

   86 funcdef: funcstart funcname . L_PARENTHES $@9 idlist R_PARENTHES $@10 block

    L_PARENTHES  shift, and go to state 143


State 103

  104 ifstmt: if_start R_PARENTHES . stmt ELSE $@13 stmt
  105       | if_start R_PARENTHES . stmt

    IF           shift, and go to state 5
    WHILE        shift, and go to state 6
    FOR          shift, and go to state 7
    FUNCTION     shift, and go to state 8
    RETURN       shift, and go to state 9
    BREAK        shift, and go to state 10
    CONTINUE     shift, and go to state 11
    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 20
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 22
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    stmt         go to state 144
    expr         go to state 30
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    block        go to state 40
    funcdef      go to state 41
    funcstart    go to state 42
    const        go to state 43
    number       go to state 44
    ifstmt       go to state 45
    if_start     go to state 46
    whilestmt    go to state 47
    whilestart   go to state 48
    forstmt      go to state 49
    returnstmt   go to state 50


State 104

  111 whilecond: L_PARENTHES . $@14 expr $@15 R_PARENTHES

    $default  reduce using rule 109 ($@14)

    $@14  go to state 145


State 105

  107 whilestmt: whilestart whilecond . stmt

    IF           shift, and go to state 5
    WHILE        shift, and go to state 6
    FOR          shift, and go to state 7
    FUNCTION     shift, and go to state 8
    RETURN       shift, and go to state 9
    BREAK        shift, and go to state 10
    CONTINUE     shift, and go to state 11
    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 20
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 22
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    stmt         go to state 146
    expr         go to state 30
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    block        go to state 40
    funcdef      go to state 41
    funcstart    go to state 42
    const        go to state 43
    number       go to state 44
    ifstmt       go to state 45
    if_start     go to state 46
    whilestmt    go to state 47
    whilestart   go to state 48
    forstmt      go to state 49
    returnstmt   go to state 50


State 106

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
  106 if_start: IF L_PARENTHES expr .

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 106 (if_start)


State 107

  114 forstmt: FOR L_PARENTHES $@16 . for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 116 (for_elist)

    expr         go to state 147
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44
    for_elist    go to state 148


State 108

  119 returnstmt: RETURN expr SEMICOLON .

    $default  reduce using rule 119 (returnstmt)


State 109

   62 call: L_PARENTHES funcdef . R_PARENTHES L_PARENTHES elist R_PARENTHES

    R_PARENTHES  shift, and go to state 149


State 110

   83 block: L_CBRACKET $@8 multi_stmts . R_CBRACKET

    R_CBRACKET  shift, and go to state 150


State 111

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   81 indexedelem: L_CBRACKET expr . $@7 COLON expr R_CBRACKET

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 80 ($@7)

    $@7  go to state 151


State 112

   75 multi_exprs_for_table: COMMA . expr multi_exprs_for_table

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 152
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 113

   73 elist_for_table: expr multi_exprs_for_table .

    $default  reduce using rule 73 (elist_for_table)


State 114

   71 objectdef: L_SBRACKET elist_for_table R_SBRACKET .

    $default  reduce using rule 71 (objectdef)


State 115

   72 objectdef: L_SBRACKET indexed R_SBRACKET .

    $default  reduce using rule 72 (objectdef)


State 116

   78 multi_indexedelem: COMMA . indexedelem multi_indexedelem

    L_CBRACKET  shift, and go to state 66

    indexedelem  go to state 153


State 117

   77 indexed: indexedelem multi_indexedelem .

    $default  reduce using rule 77 (indexed)


State 118

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   38 term: L_PARENTHES $@5 expr . R_PARENTHES

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    R_PARENTHES    shift, and go to state 154


State 119

   50 primary: L_PARENTHES funcdef R_PARENTHES .
   62 call: L_PARENTHES funcdef R_PARENTHES . L_PARENTHES elist R_PARENTHES

    L_PARENTHES  shift, and go to state 155

    $default  reduce using rule 50 (primary)


State 120

    4 multi_stmts: $@1 stmt $@2 multi_stmts .

    $default  reduce using rule 4 (multi_stmts)


State 121

   20 expr: expr AND $@3 . epsilon expr

    $default  reduce using rule 25 (epsilon)

    epsilon  go to state 156


State 122

   22 expr: expr OR $@4 . epsilon expr

    $default  reduce using rule 25 (epsilon)

    epsilon  go to state 157


State 123

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   26       | expr PLUS expr .
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    MULT  shift, and go to state 78
    DIV   shift, and go to state 79
    MOD   shift, and go to state 80

    $default  reduce using rule 26 (arexpr)


State 124

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   27       | expr MINUS expr .
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    MULT  shift, and go to state 78
    DIV   shift, and go to state 79
    MOD   shift, and go to state 80

    $default  reduce using rule 27 (arexpr)


State 125

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   28       | expr MULT expr .
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    $default  reduce using rule 28 (arexpr)


State 126

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   29       | expr DIV expr .
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    $default  reduce using rule 29 (arexpr)


State 127

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   30       | expr MOD expr .
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    $default  reduce using rule 30 (arexpr)


State 128

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   35            | expr EQUAL expr .
   36            | expr . NEQUAL expr

    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    EQUAL   error (nonassociative)
    NEQUAL  error (nonassociative)

    $default  reduce using rule 35 (boolResexpr)


State 129

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   36            | expr NEQUAL expr .

    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    EQUAL   error (nonassociative)
    NEQUAL  error (nonassociative)

    $default  reduce using rule 36 (boolResexpr)


State 130

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   31            | expr GREATER expr .
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    PLUS   shift, and go to state 76
    MINUS  shift, and go to state 77
    MULT   shift, and go to state 78
    DIV    shift, and go to state 79
    MOD    shift, and go to state 80

    GREATER        error (nonassociative)
    LESS           error (nonassociative)
    GREATER_EQUAL  error (nonassociative)
    LESS_EQUAL     error (nonassociative)

    $default  reduce using rule 31 (boolResexpr)


State 131

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   33            | expr LESS expr .
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    PLUS   shift, and go to state 76
    MINUS  shift, and go to state 77
    MULT   shift, and go to state 78
    DIV    shift, and go to state 79
    MOD    shift, and go to state 80

    GREATER        error (nonassociative)
    LESS           error (nonassociative)
    GREATER_EQUAL  error (nonassociative)
    LESS_EQUAL     error (nonassociative)

    $default  reduce using rule 33 (boolResexpr)


State 132

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   32            | expr GREATER_EQUAL expr .
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    PLUS   shift, and go to state 76
    MINUS  shift, and go to state 77
    MULT   shift, and go to state 78
    DIV    shift, and go to state 79
    MOD    shift, and go to state 80

    GREATER        error (nonassociative)
    LESS           error (nonassociative)
    GREATER_EQUAL  error (nonassociative)
    LESS_EQUAL     error (nonassociative)

    $default  reduce using rule 32 (boolResexpr)


State 133

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   34            | expr LESS_EQUAL expr .
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    PLUS   shift, and go to state 76
    MINUS  shift, and go to state 77
    MULT   shift, and go to state 78
    DIV    shift, and go to state 79
    MOD    shift, and go to state 80

    GREATER        error (nonassociative)
    LESS           error (nonassociative)
    GREATER_EQUAL  error (nonassociative)
    LESS_EQUAL     error (nonassociative)

    $default  reduce using rule 34 (boolResexpr)


State 134

   56 member: lvalue DOT IDENTIFIER .

    $default  reduce using rule 56 (member)


State 135

   66 methodcall: DOTS IDENTIFIER . L_PARENTHES elist R_PARENTHES

    L_PARENTHES  shift, and go to state 158


State 136

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   57 member: lvalue L_SBRACKET expr . R_SBRACKET

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    R_SBRACKET     shift, and go to state 159


State 137

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   67 elist: expr . multi_exprs

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    COMMA          shift, and go to state 160

    $default  reduce using rule 70 (multi_exprs)

    multi_exprs  go to state 161


State 138

   65 normcall: L_PARENTHES elist . R_PARENTHES

    R_PARENTHES  shift, and go to state 162


State 139

   46 assignmexpr: lvalue $@6 EQ . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 163
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 140

   58 member: call DOT IDENTIFIER .

    $default  reduce using rule 58 (member)


State 141

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   59 member: call L_SBRACKET expr . R_SBRACKET

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    R_SBRACKET     shift, and go to state 164


State 142

   60 call: call L_PARENTHES elist . R_PARENTHES

    R_PARENTHES  shift, and go to state 165


State 143

   86 funcdef: funcstart funcname L_PARENTHES . $@9 idlist R_PARENTHES $@10 block

    $default  reduce using rule 84 ($@9)

    $@9  go to state 166


State 144

  104 ifstmt: if_start R_PARENTHES stmt . ELSE $@13 stmt
  105       | if_start R_PARENTHES stmt .

    ELSE  shift, and go to state 167

    $default  reduce using rule 105 (ifstmt)


State 145

  111 whilecond: L_PARENTHES $@14 . expr $@15 R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 168
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 146

  107 whilestmt: whilestart whilecond stmt .

    $default  reduce using rule 107 (whilestmt)


State 147

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
  115 for_elist: expr . multi_exprs

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    COMMA          shift, and go to state 160

    $default  reduce using rule 70 (multi_exprs)

    multi_exprs  go to state 169


State 148

  114 forstmt: FOR L_PARENTHES $@16 for_elist . $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

    $default  reduce using rule 113 ($@17)

    $@17  go to state 170


State 149

   62 call: L_PARENTHES funcdef R_PARENTHES . L_PARENTHES elist R_PARENTHES

    L_PARENTHES  shift, and go to state 155


State 150

   83 block: L_CBRACKET $@8 multi_stmts R_CBRACKET .

    $default  reduce using rule 83 (block)


State 151

   81 indexedelem: L_CBRACKET expr $@7 . COLON expr R_CBRACKET

    COLON  shift, and go to state 171


State 152

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   75 multi_exprs_for_table: COMMA expr . multi_exprs_for_table

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    COMMA          shift, and go to state 112

    $default  reduce using rule 76 (multi_exprs_for_table)

    multi_exprs_for_table  go to state 172


State 153

   78 multi_indexedelem: COMMA indexedelem . multi_indexedelem

    COMMA  shift, and go to state 116

    $default  reduce using rule 79 (multi_indexedelem)

    multi_indexedelem  go to state 173


State 154

   38 term: L_PARENTHES $@5 expr R_PARENTHES .

    $default  reduce using rule 38 (term)


State 155

   62 call: L_PARENTHES funcdef R_PARENTHES L_PARENTHES . elist R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 68 (elist)

    expr         go to state 137
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    elist        go to state 174
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 156

   20 expr: expr AND $@3 epsilon . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 175
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 157

   22 expr: expr OR $@4 epsilon . expr

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 176
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 158

   66 methodcall: DOTS IDENTIFIER L_PARENTHES . elist R_PARENTHES

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 68 (elist)

    expr         go to state 137
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    elist        go to state 177
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 159

   57 member: lvalue L_SBRACKET expr R_SBRACKET .

    $default  reduce using rule 57 (member)


State 160

   69 multi_exprs: COMMA . expr multi_exprs

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 178
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 161

   67 elist: expr multi_exprs .

    $default  reduce using rule 67 (elist)


State 162

   65 normcall: L_PARENTHES elist R_PARENTHES .

    $default  reduce using rule 65 (normcall)


State 163

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   46 assignmexpr: lvalue $@6 EQ expr .

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 46 (assignmexpr)


State 164

   59 member: call L_SBRACKET expr R_SBRACKET .

    $default  reduce using rule 59 (member)


State 165

   60 call: call L_PARENTHES elist R_PARENTHES .

    $default  reduce using rule 60 (call)


State 166

   86 funcdef: funcstart funcname L_PARENTHES $@9 . idlist R_PARENTHES $@10 block

    IDENTIFIER  shift, and go to state 179

    $default  reduce using rule 99 (idlist)

    idlist  go to state 180


State 167

  104 ifstmt: if_start R_PARENTHES stmt ELSE . $@13 stmt

    $default  reduce using rule 103 ($@13)

    $@13  go to state 181


State 168

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
  111 whilecond: L_PARENTHES $@14 expr . $@15 R_PARENTHES

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 110 ($@15)

    $@15  go to state 182


State 169

  115 for_elist: expr multi_exprs .

    $default  reduce using rule 115 (for_elist)


State 170

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 . SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt

    SEMICOLON  shift, and go to state 183


State 171

   81 indexedelem: L_CBRACKET expr $@7 COLON . expr R_CBRACKET

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 184
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44


State 172

   75 multi_exprs_for_table: COMMA expr multi_exprs_for_table .

    $default  reduce using rule 75 (multi_exprs_for_table)


State 173

   78 multi_indexedelem: COMMA indexedelem multi_indexedelem .

    $default  reduce using rule 78 (multi_indexedelem)


State 174

   62 call: L_PARENTHES funcdef R_PARENTHES L_PARENTHES elist . R_PARENTHES

    R_PARENTHES  shift, and go to state 185


State 175

   20 expr: expr . AND $@3 epsilon expr
   20     | expr AND $@3 epsilon expr .
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 20 (expr)


State 176

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   22     | expr OR $@4 epsilon expr .
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr

    AND            shift, and go to state 74
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 22 (expr)


State 177

   66 methodcall: DOTS IDENTIFIER L_PARENTHES elist . R_PARENTHES

    R_PARENTHES  shift, and go to state 186


State 178

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   69 multi_exprs: COMMA expr . multi_exprs

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    COMMA          shift, and go to state 160

    $default  reduce using rule 70 (multi_exprs)

    multi_exprs  go to state 187


State 179

   98 idlist: IDENTIFIER . $@11 multi_id

    $default  reduce using rule 97 ($@11)

    $@11  go to state 188


State 180

   86 funcdef: funcstart funcname L_PARENTHES $@9 idlist . R_PARENTHES $@10 block

    R_PARENTHES  shift, and go to state 189


State 181

  104 ifstmt: if_start R_PARENTHES stmt ELSE $@13 . stmt

    IF           shift, and go to state 5
    WHILE        shift, and go to state 6
    FOR          shift, and go to state 7
    FUNCTION     shift, and go to state 8
    RETURN       shift, and go to state 9
    BREAK        shift, and go to state 10
    CONTINUE     shift, and go to state 11
    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 20
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 22
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    stmt         go to state 190
    expr         go to state 30
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    block        go to state 40
    funcdef      go to state 41
    funcstart    go to state 42
    const        go to state 43
    number       go to state 44
    ifstmt       go to state 45
    if_start     go to state 46
    whilestmt    go to state 47
    whilestart   go to state 48
    forstmt      go to state 49
    returnstmt   go to state 50


State 182

  111 whilecond: L_PARENTHES $@14 expr $@15 . R_PARENTHES

    R_PARENTHES  shift, and go to state 191


State 183

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON . for_cond SEMICOLON for_end R_PARENTHES stmt

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    expr         go to state 192
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44
    for_cond     go to state 193


State 184

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
   81 indexedelem: L_CBRACKET expr $@7 COLON expr . R_CBRACKET

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86
    R_CBRACKET     shift, and go to state 194


State 185

   62 call: L_PARENTHES funcdef R_PARENTHES L_PARENTHES elist R_PARENTHES .

    $default  reduce using rule 62 (call)


State 186

   66 methodcall: DOTS IDENTIFIER L_PARENTHES elist R_PARENTHES .

    $default  reduce using rule 66 (methodcall)


State 187

   69 multi_exprs: COMMA expr multi_exprs .

    $default  reduce using rule 69 (multi_exprs)


State 188

   98 idlist: IDENTIFIER $@11 . multi_id

    COMMA  shift, and go to state 195

    $default  reduce using rule 102 (multi_id)

    multi_id  go to state 196


State 189

   86 funcdef: funcstart funcname L_PARENTHES $@9 idlist R_PARENTHES . $@10 block

    $default  reduce using rule 85 ($@10)

    $@10  go to state 197


State 190

  104 ifstmt: if_start R_PARENTHES stmt ELSE $@13 stmt .

    $default  reduce using rule 104 (ifstmt)


State 191

  111 whilecond: L_PARENTHES $@14 expr $@15 R_PARENTHES .

    $default  reduce using rule 111 (whilecond)


State 192

   20 expr: expr . AND $@3 epsilon expr
   22     | expr . OR $@4 epsilon expr
   26 arexpr: expr . PLUS expr
   27       | expr . MINUS expr
   28       | expr . MULT expr
   29       | expr . DIV expr
   30       | expr . MOD expr
   31 boolResexpr: expr . GREATER expr
   32            | expr . GREATER_EQUAL expr
   33            | expr . LESS expr
   34            | expr . LESS_EQUAL expr
   35            | expr . EQUAL expr
   36            | expr . NEQUAL expr
  117 for_cond: expr .

    AND            shift, and go to state 74
    OR             shift, and go to state 75
    PLUS           shift, and go to state 76
    MINUS          shift, and go to state 77
    MULT           shift, and go to state 78
    DIV            shift, and go to state 79
    MOD            shift, and go to state 80
    EQUAL          shift, and go to state 81
    NEQUAL         shift, and go to state 82
    GREATER        shift, and go to state 83
    LESS           shift, and go to state 84
    GREATER_EQUAL  shift, and go to state 85
    LESS_EQUAL     shift, and go to state 86

    $default  reduce using rule 117 (for_cond)


State 193

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond . SEMICOLON for_end R_PARENTHES stmt

    SEMICOLON  shift, and go to state 198


State 194

   81 indexedelem: L_CBRACKET expr $@7 COLON expr R_CBRACKET .

    $default  reduce using rule 81 (indexedelem)


State 195

  101 multi_id: COMMA . IDENTIFIER $@12 multi_id

    IDENTIFIER  shift, and go to state 199


State 196

   98 idlist: IDENTIFIER $@11 multi_id .

    $default  reduce using rule 98 (idlist)


State 197

   86 funcdef: funcstart funcname L_PARENTHES $@9 idlist R_PARENTHES $@10 . block

    L_CBRACKET  shift, and go to state 22

    block  go to state 200


State 198

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON . for_end R_PARENTHES stmt

    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    DCOLON       shift, and go to state 21
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    $default  reduce using rule 116 (for_elist)

    expr         go to state 147
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    const        go to state 43
    number       go to state 44
    for_elist    go to state 201
    for_end      go to state 202


State 199

  101 multi_id: COMMA IDENTIFIER . $@12 multi_id

    $default  reduce using rule 100 ($@12)

    $@12  go to state 203


State 200

   86 funcdef: funcstart funcname L_PARENTHES $@9 idlist R_PARENTHES $@10 block .

    $default  reduce using rule 86 (funcdef)


State 201

  118 for_end: for_elist .

    $default  reduce using rule 118 (for_end)


State 202

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end . R_PARENTHES stmt

    R_PARENTHES  shift, and go to state 204


State 203

  101 multi_id: COMMA IDENTIFIER $@12 . multi_id

    COMMA  shift, and go to state 195

    $default  reduce using rule 102 (multi_id)

    multi_id  go to state 205


State 204

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES . stmt

    IF           shift, and go to state 5
    WHILE        shift, and go to state 6
    FOR          shift, and go to state 7
    FUNCTION     shift, and go to state 8
    RETURN       shift, and go to state 9
    BREAK        shift, and go to state 10
    CONTINUE     shift, and go to state 11
    NOT          shift, and go to state 12
    LOCAL        shift, and go to state 13
    TRUE         shift, and go to state 14
    FALSE        shift, and go to state 15
    NIL          shift, and go to state 16
    MINUS        shift, and go to state 17
    PPLUS        shift, and go to state 18
    MMINUS       shift, and go to state 19
    SEMICOLON    shift, and go to state 20
    DCOLON       shift, and go to state 21
    L_CBRACKET   shift, and go to state 22
    L_SBRACKET   shift, and go to state 23
    L_PARENTHES  shift, and go to state 24
    INTEGER      shift, and go to state 25
    FLOAT        shift, and go to state 26
    STRING       shift, and go to state 27
    IDENTIFIER   shift, and go to state 28

    stmt         go to state 206
    expr         go to state 30
    arexpr       go to state 31
    boolResexpr  go to state 32
    term         go to state 33
    assignmexpr  go to state 34
    primary      go to state 35
    lvalue       go to state 36
    member       go to state 37
    call         go to state 38
    objectdef    go to state 39
    block        go to state 40
    funcdef      go to state 41
    funcstart    go to state 42
    const        go to state 43
    number       go to state 44
    ifstmt       go to state 45
    if_start     go to state 46
    whilestmt    go to state 47
    whilestart   go to state 48
    forstmt      go to state 49
    returnstmt   go to state 50


State 205

  101 multi_id: COMMA IDENTIFIER $@12 multi_id .

    $default  reduce using rule 101 (multi_id)


State 206

  114 forstmt: FOR L_PARENTHES $@16 for_elist $@17 SEMICOLON for_cond SEMICOLON for_end R_PARENTHES stmt .

    $default  reduce using rule 114 (forstmt)
